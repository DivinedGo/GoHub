<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin - Create Puzzle</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="admin-header">
            <h1>🔒 Admin Panel - Create Puzzle</h1>
            <p>Create and configure Go puzzles for your collections</p>
            <div class="workflow-steps">
                <span class="step active" id="step-1">1. Select Collection</span>
                <span class="step" id="step-2">2. Configure Puzzle</span>
                <span class="step" id="step-3">3. Set Board Position</span>
                <span class="step" id="step-4">4. Add Solutions</span>
                <span class="step" id="step-5">5. Save Puzzle</span>
            </div>
        </div>

        <div class="nav">
            <a href="puzzles.html">User View</a>
            <a href="puzzlesadmin27988794.html">Collections</a>
            <a href="puzzlesadmincreate27988794.html">Create Puzzle</a>
            <a href="#" onclick="showHelp()">Help</a>
        </div>

        <div class="board-container">
            <!-- Step 3: Go Board Setup -->
            <div class="go-board">
                <h3>
                    🎯 Step 3: Set Initial Board Position
                    <span class="difficulty-badge" id="current-difficulty">Setup Mode</span>
                </h3>
                <div class="board-coords" id="board-container">
                    <div class="board-grid" id="board-grid">
                        <!-- Board will be generated here -->
                    </div>
                </div>
                
                <div class="stone-placement-controls">
                    <button class="btn" id="place-black" onclick="setPlaceMode('black')">⚫ Place Black</button>
                    <button class="btn btn-secondary" id="place-white" onclick="setPlaceMode('white')">⚪ Place White</button>
                    <button class="btn btn-danger" onclick="clearBoard()">🗑️ Clear Board</button>
                </div>
                
                <div class="current-mode-indicator" id="current-mode">
                    Mode: Place Black Stones
                </div>

                <div class="board-status" id="board-status">
                    Click on intersections to place stones for the initial puzzle position
                </div>
            </div>

            <!-- Control Panel -->
            <div class="control-panel">
                <h3>📋 Puzzle Configuration</h3>
                
                <!-- Step 1: Collection Selection (Prominently Featured) -->
                <div class="priority-section">
                    <h4>🎯 Step 1: Choose Target Collection</h4>
                    <div class="control-group collection-selection">
                        <label for="puzzle-collection">📚 Target Collection *</label>
                        <select id="puzzle-collection" required onchange="validateCollectionSelection()">
                            <option value="">⚠️ Please select a collection first</option>
                            <!-- Collections will be loaded here -->
                        </select>
                        <small class="help-text">You must select which collection this puzzle will be added to</small>
                    </div>
                </div>

                <!-- Step 2: Basic Puzzle Details -->
                <div class="form-section" id="puzzle-details-section">
                    <h4>✏️ Step 2: Puzzle Details</h4>
                    
                    <div class="control-group">
                        <label for="puzzle-name">📝 Puzzle Name *</label>
                        <input type="text" id="puzzle-name" required placeholder="Enter descriptive puzzle name">
                    </div>

                    <div class="control-group">
                        <label for="puzzle-description">📋 Description</label>
                        <textarea id="puzzle-description" rows="3" placeholder="Describe the puzzle objective (e.g., 'Black to play and live')"></textarea>
                    </div>

                    <div class="control-group">
                        <label for="puzzle-difficulty">⭐ Difficulty *</label>
                        <select id="puzzle-difficulty" required>
                            <option value="">Select difficulty level</option>
                            <option value="1">1 Dan - Beginner</option>
                            <option value="2">2 Dan - Easy</option>
                            <option value="3">3 Dan - Moderate</option>
                            <option value="4">4 Dan - Intermediate</option>
                            <option value="5">5 Dan - Advanced</option>
                            <option value="6">6 Dan - Expert</option>
                            <option value="7">7 Dan - Master</option>
                            <option value="8">8 Dan - Professional</option>
                            <option value="9">9 Dan - Elite</option>
                            <option value="10">10 Dan - Legendary</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="puzzle-category">🏷️ Category</label>
                        <select id="puzzle-category">
                            <option value="life-and-death">💀 Life and Death</option>
                            <option value="tesuji">⚡ Tesuji</option>
                            <option value="endgame">🏁 Endgame</option>
                            <option value="opening">🌅 Opening</option>
                            <option value="middle-game">⚔️ Middle Game</option>
                            <option value="capturing">🎯 Capturing</option>
                            <option value="connection">🔗 Connection</option>
                            <option value="other">📦 Other</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="next-to-play">🎲 Next to Play *</label>
                        <select id="next-to-play" required>
                            <option value="black">⚫ Black to play</option>
                            <option value="white">⚪ White to play</option>
                        </select>
                    </div>
                </div>

                <!-- Puzzle Settings Section -->
                <div class="admin-settings-section">
                    <h4>🔧 Puzzle Settings</h4>
                    
                    <div class="checkbox-group">
                        <label>
                            <input type="checkbox" id="puzzle-private">
                            🔒 Private Puzzle (only visible to admins)
                        </label>
                        
                        <label>
                            <input type="checkbox" id="color-transform-enabled">
                            🔄 Color Transform Enabled (allow black/white flip)
                        </label>
                        
                        <label>
                            <input type="checkbox" id="position-transform-enabled">
                            🔃 Position Transform Enabled (allow rotation/mirror)
                        </label>
                    </div>
                </div>

                <!-- Access Settings -->
                <div class="admin-settings-section">
                    <button class="settings-button" onclick="showAccessSettings()">
                        ⚙️ Access Settings
                    </button>
                    <div id="access-settings" class="access-settings-panel" style="display: none;">
                        <div style="margin: 10px 0;">
                            <label for="puzzle-rating">⭐ Rating:</label>
                            <div class="rating-stars">
                                <select id="puzzle-rating">
                                    <option value="1">⭐ (1 star)</option>
                                    <option value="2">⭐⭐ (2 stars)</option>
                                    <option value="3" selected>⭐⭐⭐ (3 stars)</option>
                                    <option value="4">⭐⭐⭐⭐ (4 stars)</option>
                                    <option value="5">⭐⭐⭐⭐⭐ (5 stars)</option>
                                </select>
                            </div>
                        </div>
                        <div style="margin: 10px 0;">
                            <label for="puzzle-author">👤 Author:</label>
                            <input type="text" id="puzzle-author" placeholder="Enter puzzle author" style="margin-top: 5px;">
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <h4>🎯 Step 4 & 5: Solutions and Save</h4>
                    <button class="btn" onclick="startVariationMode()" id="add-variations-btn">🧩 Add Solution Variations</button>
                    <button class="btn btn-success" onclick="savePuzzle()" id="save-puzzle-btn" disabled>💾 Save Puzzle to Collection</button>
                    <button class="btn btn-secondary" onclick="resetPuzzle()">🔄 Reset All</button>
                </div>
            </div>
        </div>

        <!-- Step 4: Variations Section -->
        <div class="variations-container" id="variations-section" style="display: none;">
            <h3>
                🧩 Step 4: Solution Variations 
                <span class="variation-counter" id="variation-counter">0 variations</span>
            </h3>
            
            <div class="move-input-section">
                <h4>🎯 Add Solution Moves</h4>
                <p>Click on the board to add moves. Mark each sequence as correct or incorrect.</p>
                
                <div style="margin: 15px 0;">
                    <button class="btn" onclick="startNewVariation()">➕ New Variation</button>
                    <button class="btn btn-secondary" onclick="undoLastMove()">↶ Undo Move</button>
                    <button class="btn btn-danger" onclick="clearCurrentVariation()">🗑️ Clear Variation</button>
                </div>

                <div class="admin-settings-section">
                    <h4>Variation Type</h4>
                    <div class="checkbox-group" style="flex-direction: row; gap: 20px;">
                        <label>
                            <input type="radio" name="variation-type" value="correct" checked>
                            ✅ Correct Solution
                        </label>
                        <label>
                            <input type="radio" name="variation-type" value="incorrect">
                            ❌ Incorrect Solution
                        </label>
                    </div>
                </div>
            </div>

            <div id="variations-list">
                <!-- Variations will be displayed here -->
            </div>
        </div>

        <!-- Status messages -->
        <div id="status-messages"></div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('helpModal')">&times;</span>
            <h2>How to Create a Puzzle</h2>
            <div class="status-info">
                <h3>Step 1: Set up the initial position</h3>
                <ul>
                    <li>Select "Place Black Stones" or "Place White Stones"</li>
                    <li>Click on board intersections to place stones</li>
                    <li>Create the initial puzzle position</li>
                </ul>
                
                <h3>Step 2: Configure puzzle details</h3>
                <ul>
                    <li>Select the collection for this puzzle</li>
                    <li>Enter a descriptive name and description</li>
                    <li>Set difficulty (1-10) and category</li>
                    <li>Choose who plays next (Black or White)</li>
                </ul>
                
                <h3>Step 3: Add solution variations</h3>
                <ul>
                    <li>Click "Add Solution Variations" to enter variation mode</li>
                    <li>Click on the board to add moves in sequence</li>
                    <li>Mark each variation as "Correct" or "Incorrect"</li>
                    <li>Add multiple variations to show different lines of play</li>
                </ul>
                
                <h3>Step 4: Save the puzzle</h3>
                <ul>
                    <li>Review your puzzle setup and variations</li>
                    <li>Click "Save Puzzle" to add it to the collection</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let board = Array(19).fill().map(() => Array(19).fill(null));
        let placeMode = 'black'; // 'black' or 'white'
        let variationMode = false;
        let currentVariation = [];
        let variations = [];
        let moveSequence = [];
        let collections = [];
        let koPosition = null; // For ko rule enforcement

        // Initialize board on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeBoard();
            loadCollections();
            
            // Initialize UI state
            const puzzleDetailsSection = document.getElementById('puzzle-details-section');
            if (puzzleDetailsSection) {
                puzzleDetailsSection.style.opacity = '0.5';
                puzzleDetailsSection.style.pointerEvents = 'none';
            }
            
            const savePuzzleBtn = document.getElementById('save-puzzle-btn');
            if (savePuzzleBtn) {
                savePuzzleBtn.disabled = true;
            }
            
            // Check if collection ID is provided in URL
            const urlParams = new URLSearchParams(window.location.search);
            const collectionId = urlParams.get('collection');
            if (collectionId) {
                setTimeout(() => {
                    document.getElementById('puzzle-collection').value = collectionId;
                    validateCollectionSelection();
                }, 500);
            } else {
                // Show initial instruction
                showStatusMessage('Welcome! Start by selecting which collection you want to add this puzzle to.', 'info');
            }
        });

        // Initialize the Go board
        function initializeBoard() {
            const boardGrid = document.getElementById('board-grid');
            boardGrid.innerHTML = '';

            // Create board lines
            const linesContainer = document.createElement('div');
            linesContainer.className = 'board-lines';
            
            // Create 19 horizontal and vertical lines for a 19x19 board
            for (let i = 0; i < 19; i++) {
                // Horizontal lines - positioned from 0 to 432px in 18 intervals
                const hLine = document.createElement('div');
                hLine.className = 'board-line horizontal';
                hLine.style.top = `${i * 24}px`;
                linesContainer.appendChild(hLine);
                
                // Vertical lines - positioned from 0 to 432px in 18 intervals
                const vLine = document.createElement('div');
                vLine.className = 'board-line vertical';
                vLine.style.left = `${i * 24}px`;
                linesContainer.appendChild(vLine);
            }
            
            boardGrid.appendChild(linesContainer);

            // Create coordinate labels
            const coords = 'ABCDEFGHJKLMNOPQRST';
            
            // Create intersections
            for (let row = 0; row < 19; row++) {
                for (let col = 0; col < 19; col++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.dataset.row = row;
                    intersection.dataset.col = col;
                    intersection.onclick = () => handleIntersectionClick(row, col);
                    
                    // Position intersection at line crossings (exactly on the lines)
                    intersection.style.left = `${col * 24}px`;
                    intersection.style.top = `${row * 24}px`;
                    
                    // Add coordinate labels only on the very edges
                    if (row === 0 && col >= 0 && col <= 18) {
                        const coordLabel = document.createElement('div');
                        coordLabel.className = 'coord-label coord-top';
                        coordLabel.textContent = coords[col];
                        intersection.appendChild(coordLabel);
                    }
                    if (row === 18 && col >= 0 && col <= 18) {
                        const coordLabel = document.createElement('div');
                        coordLabel.className = 'coord-label coord-bottom';
                        coordLabel.textContent = coords[col];
                        intersection.appendChild(coordLabel);
                    }
                    if (col === 0 && row >= 0 && row <= 18) {
                        const coordLabel = document.createElement('div');
                        coordLabel.className = 'coord-label coord-left';
                        coordLabel.textContent = 19 - row;
                        intersection.appendChild(coordLabel);
                    }
                    if (col === 18 && row >= 0 && row <= 18) {
                        const coordLabel = document.createElement('div');
                        coordLabel.className = 'coord-label coord-right';
                        coordLabel.textContent = 19 - row;
                        intersection.appendChild(coordLabel);
                    }
                    
                    boardGrid.appendChild(intersection);
                }
            }
            
            // Add star points
            addStarPoints(boardGrid);
        }

        // Add star points to the board
        function addStarPoints(boardGrid) {
            const starPoints = [
                [3, 3], [3, 9], [3, 15],
                [9, 3], [9, 9], [9, 15],
                [15, 3], [15, 9], [15, 15]
            ];
            
            starPoints.forEach(([row, col]) => {
                const starPoint = document.createElement('div');
                starPoint.className = 'star-point';
                starPoint.style.left = `${col * 24}px`;
                starPoint.style.top = `${row * 24}px`;
                boardGrid.appendChild(starPoint);
            });
        }

        // Handle intersection click
        function handleIntersectionClick(row, col) {
            if (variationMode) {
                addMoveToVariation(row, col);
            } else {
                placeStone(row, col);
            }
        }

        // Place stone on board
        function placeStone(row, col) {
            if (board[row][col] !== null) {
                // Remove stone if already placed
                board[row][col] = null;
            } else {
                // Place new stone
                board[row][col] = placeMode;
            }
            updateBoardDisplay();
        }

        // Add move to current variation
        function addMoveToVariation(row, col) {
            if (board[row][col] !== null) {
                showStatusMessage('Cannot place stone on occupied intersection', 'error');
                return;
            }

            const nextToPlay = document.getElementById('next-to-play').value;
            const moveColor = (moveSequence.length % 2 === 0) ? nextToPlay : (nextToPlay === 'black' ? 'white' : 'black');
            
            const move = {
                row: row,
                col: col,
                color: moveColor,
                moveNumber: moveSequence.length + 1
            };

            // Place the stone on the board for variation mode
            board[row][col] = moveColor;
            moveSequence.push(move);
            currentVariation.push(move);
            updateBoardDisplay();
            updateVariationDisplay();
            
            showStatusMessage(`Added ${moveColor} stone at move ${move.moveNumber}`, 'success');
        }

        // Update board display
        function updateBoardDisplay() {
            const intersections = document.querySelectorAll('.intersection');
            
            intersections.forEach(intersection => {
                const row = parseInt(intersection.dataset.row);
                const col = parseInt(intersection.dataset.col);
                
                // Remove existing stones
                const existingStone = intersection.querySelector('.stone');
                if (existingStone) {
                    intersection.removeChild(existingStone);
                }

                // Update intersection state
                if (board[row][col] !== null) {
                    intersection.classList.add('occupied');
                } else {
                    intersection.classList.remove('occupied');
                }

                // Add stone if present
                if (board[row][col] !== null) {
                    const stone = document.createElement('div');
                    stone.className = `stone ${board[row][col]}`;
                    intersection.appendChild(stone);
                }

                // Add move numbers for variations
                if (variationMode) {
                    const move = moveSequence.find(m => m.row === row && m.col === col);
                    if (move) {
                        const stone = intersection.querySelector('.stone');
                        if (stone) {
                            stone.textContent = move.moveNumber;
                            stone.style.color = move.color === 'black' ? 'white' : 'black';
                            stone.style.fontSize = '10px';
                            stone.style.fontWeight = 'bold';
                            stone.style.display = 'flex';
                            stone.style.alignItems = 'center';
                            stone.style.justifyContent = 'center';
                        }
                    }
                }
            });
        }

        // Set stone placement mode
        function setPlaceMode(mode) {
            placeMode = mode;
            const emoji = mode === 'black' ? '⚫' : '⚪';
            const colorName = mode.charAt(0).toUpperCase() + mode.slice(1);
            
            document.getElementById('current-mode').textContent = `Mode: Place ${colorName} Stones ${emoji}`;
            document.getElementById('board-status').textContent = `Click on intersections to place ${colorName.toLowerCase()} stones`;
            
            // Update button styles
            document.getElementById('place-black').className = mode === 'black' ? 'btn' : 'btn btn-secondary';
            document.getElementById('place-white').className = mode === 'white' ? 'btn' : 'btn btn-secondary';
        }

        // Clear board
        function clearBoard() {
            if (variationMode) {
                clearCurrentVariation();
            } else {
                board = Array(19).fill().map(() => Array(19).fill(null));
                koPosition = null; // Reset ko position
                updateBoardDisplay();
            }
        }

        // Start variation mode
        function startVariationMode() {
            // Validate that basic puzzle info is filled
            const collectionId = document.getElementById('puzzle-collection').value;
            const name = document.getElementById('puzzle-name').value;
            const difficulty = document.getElementById('puzzle-difficulty').value;
            
            if (!collectionId) {
                showStatusMessage('Please select a collection first', 'error');
                return;
            }
            
            if (!name || !difficulty) {
                showStatusMessage('Please fill in puzzle name and difficulty first', 'error');
                return;
            }
            
            // Update step progress
            updateStepProgress(4);
            
            variationMode = true;
            moveSequence = [];
            document.getElementById('variations-section').style.display = 'block';
            document.getElementById('current-difficulty').textContent = 'Variation Mode';
            document.getElementById('board-status').textContent = 'Click on the board to add moves for solution variations';
            updateVariationCounter();
            
            // Enable save button
            document.getElementById('save-puzzle-btn').disabled = false;
            
            showStatusMessage('Variation mode started. Click on the board to add moves.', 'info');
        }

        // Start new variation
        function startNewVariation() {
            if (currentVariation.length > 0) {
                saveCurrentVariation();
            }
            currentVariation = [];
            moveSequence = [];
            
            // Reset board to initial position
            resetBoardToInitial();
            updateVariationDisplay();
        }

        // Save current variation
        function saveCurrentVariation() {
            if (currentVariation.length === 0) return;

            const variationType = document.querySelector('input[name="variation-type"]:checked').value;
            
            variations.push({
                moves: [...currentVariation],
                type: variationType,
                id: Date.now()
            });

            updateVariationDisplay();
            showStatusMessage(`${variationType.charAt(0).toUpperCase() + variationType.slice(1)} variation saved!`, 'success');
        }

        // Reset board to initial position
        function resetBoardToInitial() {
            // Keep only the initial stones, remove variation moves
            for (let move of moveSequence) {
                board[move.row][move.col] = null;
            }
            updateBoardDisplay();
        }

        // Undo last move
        function undoLastMove() {
            if (moveSequence.length === 0) return;

            const lastMove = moveSequence.pop();
            currentVariation.pop();
            board[lastMove.row][lastMove.col] = null;
            updateBoardDisplay();
            updateVariationDisplay();
        }

        // Clear current variation
        function clearCurrentVariation() {
            // Remove variation stones from board
            moveSequence.forEach(move => {
                board[move.row][move.col] = null;
            });
            
            currentVariation = [];
            moveSequence = [];
            updateBoardDisplay();
            updateVariationDisplay();
            showStatusMessage('Variation cleared', 'info');
        }

        // Reset board to initial position (keeping only setup stones)
        function resetBoardToInitial() {
            // Clear only variation moves, keep setup stones
            moveSequence.forEach(move => {
                board[move.row][move.col] = null;
            });
            updateBoardDisplay();
        }

        // Update variation counter
        function updateVariationCounter() {
            const counter = document.getElementById('variation-counter');
            const count = variations.length;
            counter.textContent = `${count} variation${count !== 1 ? 's' : ''}`;
        }

        // Update variation display
        function updateVariationDisplay() {
            const variationsList = document.getElementById('variations-list');
            
            let html = '';
            
            // Show current variation being edited
            if (currentVariation.length > 0) {
                html += `
                    <div class="variation">
                        <div class="variation-header">
                            <strong>Current Variation (${currentVariation.length} moves)</strong>
                            <button class="btn btn-secondary" onclick="saveCurrentVariation()">Save Variation</button>
                        </div>
                        <div class="variation-moves">
                            ${currentVariation.map(move => 
                                `${move.moveNumber}.${move.color.charAt(0).toUpperCase()} ${String.fromCharCode(65 + move.col)}${19 - move.row}`
                            ).join(' ')}
                        </div>
                    </div>
                `;
            }

            // Show saved variations
            variations.forEach(variation => {
                html += `
                    <div class="variation ${variation.type}">
                        <div class="variation-header">
                            <strong>${variation.type.charAt(0).toUpperCase() + variation.type.slice(1)} Solution (${variation.moves.length} moves)</strong>
                            <button class="btn btn-danger" onclick="deleteVariation(${variation.id})">Delete</button>
                        </div>
                        <div class="variation-moves">
                            ${variation.moves.map(move => 
                                `${move.moveNumber}.${move.color.charAt(0).toUpperCase()} ${String.fromCharCode(65 + move.col)}${19 - move.row}`
                            ).join(' ')}
                        </div>
                    </div>
                `;
            });

            variationsList.innerHTML = html;
            
            // Update variation counter
            const counter = document.getElementById('variation-counter');
            if (counter) {
                const count = variations.length;
                counter.textContent = `${count} variation${count !== 1 ? 's' : ''}`;
            }
        }

        // Delete variation
        function deleteVariation(variationId) {
            variations = variations.filter(v => v.id !== variationId);
            updateVariationDisplay();
            showStatusMessage('Variation deleted', 'info');
        }

        // Validate collection selection and update UI
        function validateCollectionSelection() {
            const collectionSelect = document.getElementById('puzzle-collection');
            const selectedCollection = collectionSelect.value;
            const puzzleDetailsSection = document.getElementById('puzzle-details-section');
            const addVariationsBtn = document.getElementById('add-variations-btn');
            const savePuzzleBtn = document.getElementById('save-puzzle-btn');
            
            // Update step indicators
            const step1 = document.getElementById('step-1');
            const step2 = document.getElementById('step-2');
            
            if (selectedCollection) {
                // Collection selected - enable next steps
                step1.classList.add('completed');
                step1.classList.remove('active');
                step2.classList.add('active');
                
                // Show selected collection name
                const selectedOption = collectionSelect.options[collectionSelect.selectedIndex];
                showStatusMessage(`Collection selected: ${selectedOption.textContent}`, 'success');
                
                // Enable form sections
                puzzleDetailsSection.style.opacity = '1';
                puzzleDetailsSection.style.pointerEvents = 'auto';
                
            } else {
                // No collection selected - disable subsequent steps
                step1.classList.remove('completed');
                step1.classList.add('active');
                step2.classList.remove('active');
                
                // Disable form sections
                puzzleDetailsSection.style.opacity = '0.5';
                puzzleDetailsSection.style.pointerEvents = 'none';
                
                // Keep save button disabled
                savePuzzleBtn.disabled = true;
                
                showStatusMessage('Please select a collection first', 'info');
            }
        }

        // Update step progress
        function updateStepProgress(currentStep) {
            const steps = ['step-1', 'step-2', 'step-3', 'step-4', 'step-5'];
            
            steps.forEach((stepId, index) => {
                const step = document.getElementById(stepId);
                if (index < currentStep - 1) {
                    step.classList.add('completed');
                    step.classList.remove('active');
                } else if (index === currentStep - 1) {
                    step.classList.add('active');
                    step.classList.remove('completed');
                } else {
                    step.classList.remove('active', 'completed');
                }
            });
        }

        // Load collections
        async function loadCollections() {
            try {
                const response = await fetch('/api/admin/collections', {
                    headers: {
                        'x-admin-key': 'admin123' // In production, this should be properly secured
                    }
                });
                if (!response.ok) throw new Error('Failed to fetch collections');
                
                collections = await response.json();
                const select = document.getElementById('puzzle-collection');
                
                collections.forEach(collection => {
                    const option = document.createElement('option');
                    option.value = collection._id;
                    option.textContent = collection.name;
                    select.appendChild(option);
                });

            } catch (error) {
                console.error('Error loading collections:', error);
                showStatusMessage('Error loading collections', 'error');
            }
        }

        // Save puzzle
        async function savePuzzle() {
            // Validate form
            const collectionId = document.getElementById('puzzle-collection').value;
            const collectionSelect = document.getElementById('puzzle-collection');
            const collectionName = collectionSelect.options[collectionSelect.selectedIndex].textContent;
            const name = document.getElementById('puzzle-name').value;
            const difficulty = document.getElementById('puzzle-difficulty').value;
            const nextToPlay = document.getElementById('next-to-play').value;

            if (!collectionId || !name || !difficulty || !nextToPlay) {
                showStatusMessage('Please fill in all required fields', 'error');
                return;
            }

            if (variations.length === 0) {
                showStatusMessage('Please add at least one solution variation', 'error');
                return;
            }

            // Update step progress
            updateStepProgress(5);

            // Show confirmation message with collection name
            if (!confirm(`Save puzzle "${name}" to collection "${collectionName}"?`)) {
                return;
            }

            // Save current variation if exists
            if (currentVariation.length > 0) {
                saveCurrentVariation();
            }

            // Prepare puzzle data
            const puzzleData = {
                collectionId: collectionId,
                name: name,
                description: document.getElementById('puzzle-description').value,
                difficulty: parseInt(difficulty),
                category: document.getElementById('puzzle-category').value,
                nextToPlay: nextToPlay,
                initialPosition: board.map(row => [...row]),
                variations: variations.map(v => ({
                    moves: v.moves,
                    correct: v.type === 'correct'
                })),
                // Additional settings from the enhanced interface
                private: document.getElementById('puzzle-private').checked,
                colorTransformEnabled: document.getElementById('color-transform-enabled').checked,
                positionTransformEnabled: document.getElementById('position-transform-enabled').checked,
                rating: parseInt(document.getElementById('puzzle-rating').value) || 3,
                author: document.getElementById('puzzle-author').value || 'Admin'
            };

            try {
                const response = await fetch('/api/puzzles', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-admin-key': 'admin123' // In production, this should be properly secured
                    },
                    body: JSON.stringify(puzzleData)
                });

                if (!response.ok) {
                    throw new Error('Failed to save puzzle');
                }

                const result = await response.json();
                showStatusMessage(`Puzzle "${name}" saved successfully to collection "${collectionName}"!`, 'success');
                
                // Update step to completed
                document.getElementById('step-5').classList.add('completed');
                
                // Ask if user wants to create another puzzle
                setTimeout(() => {
                    if (confirm('Puzzle saved! Would you like to create another puzzle?')) {
                        resetPuzzle();
                    } else {
                        window.location.href = 'puzzlesadmin27988794.html';
                    }
                }, 2000);

            } catch (error) {
                console.error('Error saving puzzle:', error);
                showStatusMessage('Error saving puzzle. Please try again.', 'error');
            }
        }

        // Show/hide access settings
        function showAccessSettings() {
            const accessSettings = document.getElementById('access-settings');
            if (accessSettings.style.display === 'none') {
                accessSettings.style.display = 'block';
            } else {
                accessSettings.style.display = 'none';
            }
        }

        // Reset puzzle
        function resetPuzzle() {
            // Reset board
            board = Array(19).fill().map(() => Array(19).fill(null));
            
            // Reset form
            document.getElementById('puzzle-name').value = '';
            document.getElementById('puzzle-description').value = '';
            document.getElementById('puzzle-difficulty').value = '';
            document.getElementById('puzzle-category').value = 'life-and-death';
            document.getElementById('next-to-play').value = 'black';
            
            // Reset variations
            variations = [];
            currentVariation = [];
            moveSequence = [];
            variationMode = false;
            
            // Hide variations section
            document.getElementById('variations-section').style.display = 'none';
            
            // Update displays
            updateBoardDisplay();
            setPlaceMode('black');
            
            showStatusMessage('Puzzle reset', 'info');
        }

        // Show help modal
        function showHelp() {
            document.getElementById('helpModal').style.display = 'block';
        }

        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Show status message
        function showStatusMessage(message, type) {
            const container = document.getElementById('status-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `status-message status-${type}`;
            messageDiv.textContent = message;
            
            container.appendChild(messageDiv);
            
            // Remove message after 5 seconds
            setTimeout(() => {
                if (container.contains(messageDiv)) {
                    container.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
    </script>
</body>
</html>
